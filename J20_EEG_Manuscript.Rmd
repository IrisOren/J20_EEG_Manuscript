
---
title: "J20_EEG_Manuscript"
author: "Iris Oren"
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document: default
  pdf_document: default
---


### Description
This .rmd file processes the Data to create all figures for Brown & Ying et a

* Data
  + Spike counts by SCPP4: SCPP4.tcl was run on 8s epochs of Data, with glitch=200. The processor generated text files, containing: loss| spike counts| burst count| delta power| theta power. SCPP4.tcl outputs: "ndfFilename_SCPP4V1.txt", organised in individual folders by AnimalID
  (Raw Data: Dropbox/Analysis/Neuroarchiver/J20EEG/SCPP4V1).
  + Spike counts by Matthias's scripts: To be added
  + Metadata: RecordingInformation
 



###Package Initialisation 

First, load packages and source files
```{r LoadPackages_Chunk, echo=FALSE, include=FALSE}
library(lubridate)
library(plyr)
library(Rmisc)
library(lazyeval) #Needed for using ggplot2 library
library(ggplot2)
library(grid)
library(cowplot)
library(stringr)
library(scatterplot3d)
library(data.table)
library(perm)
library(circular)
library(plotrix)
library(readr)  #for col_skip in read.csv
library(lme4)
library(lsmeans)
library(multcomp)
library(CircOutlier)
library(dplyr)


sourceDir <- function(path, trace = TRUE, ...) {
    for (nm in list.files(path, pattern = "\\.[Rr]$")) {
       if(trace) cat(nm,":")           
       source(file.path(path, nm), ...)
       if(trace) cat("\n")
    }
}
sourceDir("R/")  #All function in R/ folder relative to project
```
### Datafile and variable initialisation
Specify files and folders to be used
```{r VariableInitialisationChunk, ECHO=FALSE}
NDFDataParentFolder<-"~/Dropbox/ANALYSIS/Neuroarchiver/J20EEG/SCPP4V1"
RecordingInfoFile<-"./Data/RecordingInfo.csv"
FalsePositiveFile<-"./Data/SCPP4V1_Performance.csv"
LossIntervalPercentageFile<-"./Data/LossIntervalPercentage.csv"

#RecordingInfoFile<-"./Data/RecordingInfo_WT_VideoScoring.csv"
OutputFolder<-"./Output"
```

Import summary recording information dataframe
```{r ImportRecordingInformation, ECHO=FALSE, include=FALSE}
detach("package:dplyr", character.only = TRUE)
library("dplyr", character.only = TRUE)

FalsePositiveCutOff=0.1
LossIntervalPercentageThreshold<-5 #Limit for percent of intervals lost to include animal in analysis

SummaryDataframe<-read.csv(RecordingInfoFile, na = "empty")
SummaryDataframe$AnimalID<-as.character(SummaryDataframe$AnimalID)
SummaryDataframe$DrugDate<-as.character(SummaryDataframe$DrugDate)
SummaryDataframe$DrugTime<-as.character(SummaryDataframe$DrugTime)
SummaryDataframe$TimeZone<-as.character(SummaryDataframe$TimeZone) #Set to "Europe/london" except for animals when clocks changed from GMT-> daylight savings and they stayed on GMT which should be set to "UTC" 
SummaryDataframe$DrugDateTime<-  paste(as.character(SummaryDataframe$DrugDate)
, as.character(SummaryDataframe$DrugTime), " ")
SummaryDataframe$Fig1_IISRate<-as.character(SummaryDataframe$Fig1_IISRate)
SummaryDataframe$DOB<-as.character(SummaryDataframe$DOB)

#Apend the calculated false positive rate information to SummaryDataframe

FalsePositives<-read.csv(file=FalsePositiveFile, header = TRUE)
FalsePositives<-dplyr::select(FalsePositives, AnimalID, FalsePositiveRateWithNa, FalsePositiveRateNoNa)
SummaryDataframe$FalsePositiveRate<-FalsePositives$FalsePositiveRateNoNa


#Apend LossIntervalPercentage information to SummaryDataFrame

LossIntervalPercentage<-read.csv(file=LossIntervalPercentageFile, header = TRUE)
LossIntervalPercentage<-dplyr::select(LossIntervalPercentage, AnimalID, LossIntervalPercentage)
SummaryDataframe$LossIntervalPercentage<-LossIntervalPercentage$LossIntervalPercentage

#Append recording protocol information
RecordingProtocol<-read.csv(file=LossIntervalPercentageFile, header = TRUE)
RecordingProtocol<-dplyr::select(RecordingProtocol, AnimalID, Protocol)
SummaryDataframe$Protocol<-RecordingProtocol$Protocol


#Select animals where false positive is < FalsePositiveThreshold
SummaryDataframe<-filter(SummaryDataframe, FalsePositiveRate<FalsePositiveCutOff)

#Select animals that will be included in MS as the subset that will be included in Fig1
SummaryDataframe<-filter(SummaryDataframe, Fig1_IISRate=="YES")

#Add age variable as difference of DOB and first NDF file
SummaryDataframe$Age<-as.POSIXct(SummaryDataframe$FirstNDF, origin="1970-01-01", tz="Europe/london")-strptime(SummaryDataframe$DOB, format="%d/%m/%y", tz="Europe/london")






```


2. For each AnimalID to be included:
  i. Set AnimalID subfolder
  ii. Create SCPPP_dataframe from all processor characteristics .txt files 
  iii. Add variables for time and for separating drug and treatment conditions
  iv. Add variable for excluding based on  loss and high delta intervals

3. Save to a dataframe in long format. To access elements filter by AnimalID
  OR Import SCPPDataframeAll.csv which has been created previously

  
  
```{r ImportAndTransformNDFOutput_chunk, ECHO=FALSE}
if(file.exists("./Output/SCPPDataframeAll.csv")){
  SCPPDataframeAll<-read.csv("./Output/SCPPDataframeAll.csv")
  RemoveOption<-0
  } else{  #Else create SCPPDataframeAll.csv
    
      #Initialise variables all animals
     # SCPPDataframeList<-list()
      SCPPDataframeAll<-data.frame()
      
      for(i in 1:nrow(SummaryDataframe)){     #Loop through animals
      
        SCPPDataframe<-data.frame() #Initialise dataframe for current animal
        
       #Write AnimalID, genotype and TimeZone to variable for current animal
              AnimalIDCurrent<-SummaryDataframe$AnimalID[i]
              GenotypeCurrent<-SummaryDataframe$Genotype[i]
              TimeZoneCurrent<-SummaryDataframe$TimeZone[i]
              DrugDateTimeCurrent<-SummaryDataframe$DrugDateTime[i] 
        #i. Set AnimalID subfolder
        
          FullPath<-paste(NDFDataParentFolder, AnimalIDCurrent, sep="/")
       FullPath<-paste(FullPath, "/", sep="")
       #Next import all files in input_path to create a new r dataframe called             `SCPPDataframe'
          SCPPDataframe<-ImportData(FullPath)
        
          

           # Exclude Loss >20 % and Artifact intervals which have delta power >1000ksq counts and write the number of ExcludedIntervals to ExcludedIntervalsVariable in SCPPDataframe
          LossThreshold=20
          DeltaThreshold=1000  
          
         
           # Add Variable for ExcludeInterval: If Loss>LossThreshold or  delta power >DeltaThreshold
          
          ExcludedIntervalsVariable<-which((SCPPDataframe$Loss>LossThreshold)| (SCPPDataframe$Delta>DeltaThreshold))
          #Set ExcludeInterval to a default of 0
          SCPPDataframe$ExcludeInterval<-0
          #ExcludeInterval<-1 for exclusion
          SCPPDataframe$ExcludeInterval[ExcludedIntervalsVariable]<-1
            

          
        #Apend time information to Data frame  
          SCPPDataframe <- GetTimeOfDayAndDate(SCPPDataframe, TimeZoneCurrent)
          SCPPDataframe$TimeOfDay<-as.POSIXct(SCPPDataframe$TimeOfDay)
          
        #Apend a Treatment variable to the dataframe, based on DrugDateTime as specified in Fig1SummaryDataframe 
          Treatment<-c()
          Treatment[which(SCPPDataframe$TimeOfDay<strptime(DrugDateTimeCurrent, "%d/%m/%y %H:%M:%S"))]="Control"
          #If there are more intervals than control condition ie. if drug given
          if(length(Treatment)<nrow(SCPPDataframe)){
            Treatment[length(Treatment)+1]="Unknown"
            Treatment[(length(Treatment)+1):(dim(SCPPDataframe))[1]]="Drug"
          }
      #apend Treatment variable to SCPPDataframe
      SCPPDataframe<-cbind(SCPPDataframe, Treatment)

         
      #Apend AnimalID variable and Genotype
          AnimalIDVariable<-rep(AnimalIDCurrent, nrow(SCPPDataframe))
          SCPPDataframe<-cbind(SCPPDataframe, AnimalIDVariable)
          Genotype<-rep(GenotypeCurrent, nrow(SCPPDataframe))
          SCPPDataframe<-cbind(SCPPDataframe, Genotype)
      
       #Apend SCPPDataframe to SCPPDataframeAll. To access an animal, used "filter()" 
          SCPPDataframeAll<-rbind(SCPPDataframeAll, SCPPDataframe)
      }
  
    #Add LightDark variable where LightDark=TRUE is lights on
    Hour<-hour(SCPPDataframeAll$TimeOfDay)
    SCPPDataframeAll$LightDark <- Hour %in% seq(7, 18)
    
    #Add ThetaOverDelta
    SCPPDataframeAll$ThetaOverDelta<-SCPPDataframeAll$Theta/SCPPDataframeAll$Delta
  RemoveOption<-1
    }

if(RemoveOption==1){
    rm(SCPPDataframe, FalsePositives, LossIntervalPercentage, Temp, Treatment, Genotype)
}
```


Save SCPPDataframeAll to output directory
```{r SaveSCPPDataframeAllChunk, echo=FALSE}
        
if(file.exists("./Output/SCPPDataframeAll.csv")==0){
        write.csv(SCPPDataframeAll,"./Output/SCPPDataframeAll.csv")
}
  

```

Make a copy of SCPPDataFrameAllOriginal and save to disk and exclude intervals from SCPPDataframeAll
```{r ExcludeIntervals, echo=FALSE, include=TRUE}
SCPPDataframeAllOriginal<-SCPPDataframeAll
SCPPDataframeAll<-filter(SCPPDataframeAll, ExcludeInterval==0)
if(file.exists("./Output/SCPPDataframeAllOriginal.csv")==0){
          write.csv(SCPPDataframeAllOriginal,"./Output/SCPPDataframeOriginal.csv")
}
rm(SCPPDataframeAllOriginal)

```
#######################

 
```{r AgeOfAnimals, echo = TRUE}
MeanAgeOfAnimals<-mean(as.numeric(SummaryDataframe$Age), na.rm=TRUE)
MeanAgeOfAnimalsMonths<-MeanAgeOfAnimals/30.5

SEMAgeOfAnimals<-sd(as.numeric(SummaryDataframe$Age), na.rm = TRUE)/sqrt(nrow(SummaryDataframe))

MinAge<-min(as.numeric(SummaryDataframe$Age), na.rm=TRUE)/30.5
MaxAge<-max(as.numeric(SummaryDataframe$Age), na.rm=TRUE)/30.5

```
Mean age of animals = `r MeanAgeOfAnimals` days

Mean age of animals in months = `r MeanAgeOfAnimalsMonth` Months

SEM = `r SEMAgeOfAnimals` days

Age range = [`r MinAge`, `r MaxAge`] days

```{r MeanFalsePositiveRate}
MeanFalsePositiveRate<-mean(SummaryDataframe$FalsePositiveRate)
```

###########################################################
# Figure 1: Spike count measure between genotype
######
###Fig 1A: Example of IIS
```{r ExampleIIS, echo=TRUE, include=TRUE}
IISFilename<-"./Data/M1495229694_Chan2.csv" #From J0460 tmin=688s
xZoomStart=4.125
xZoomEnd=4.375
IISTrace<-read.csv(IISFilename, header = FALSE)
IISTrace$mV<-IISTrace$V1*400*10^(-6)
IISTrace$Time<-seq(from=0,to=((nrow(IISTrace)-1)/512), by=1/512)
IISPlot<-ggplot(IISTrace, aes(x=Time, y=mV))+
  geom_line() +
  scale_y_continuous(limits=c(16.7, 18.05))+
  geom_segment(x=25, xend=30, y=16.75, yend=16.75)+
  geom_segment(x=25, xend=25, y=16.75, yend=17) +
  geom_text(x=((xZoomStart+xZoomEnd)/2), y=18, label="*", size=8)+
  #geom_text(x=27.5, y=16.7, label="5 s") +
  #geom_text(x=28, y=16.88, label = "0.25 mV")+
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(), 
        axis.ticks.x = element_blank(), 
        axis.line.x = element_blank(),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank())
  

IISPlot

ggsave("Output/Figures/Fig1/Fig1A.png", device="png", dpi=600)

#Zoomed expansion 250ms

IISTraceZoom<-filter(IISTrace, Time>xZoomStart & Time<xZoomEnd)
IISPlotZoom<-ggplot(IISTraceZoom, aes(x=Time, y=mV))+
  geom_line() +
  #scale_y_continuous(limits=c(16.7, 17.5))+
  theme(axis.title.x = element_blank(), 
        axis.text.x = element_blank(), 
        axis.ticks.x = element_blank(), 
        axis.line.x = element_blank(),
        axis.title.y = element_blank(), 
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        axis.line.y = element_blank())

IISPlotZoom

ggsave("Output/Figures/Fig1/Fig1AZoom.png", device="png", dpi=600 )

rm(IISTrace, IISTraceZoom)
```
#####
This figure requires a dataframe Fig1SummaryDataframe=AnimalID|Genotype|TimeZone|Spike rate measure = Number of intervals greater than 0 spikes

Steps:
1. Create Fig1SummaryDataframe from recordingInformation. 
```{r create_fig1_dataframe, ECHO=FALSE}
  Fig1SummaryDataframe<-SummaryDataframe[, c("AnimalID", "Genotype", "TimeZone", "DrugDateTime", "Fig1_IISRate", "LossIntervalPercentage")]
#Remove rows with missing variables
  Fig1SummaryDataframe<-Fig1SummaryDataframe[complete.cases(Fig1SummaryDataframe),]
```
  
2. Select animals that will be used in the analysis: animals with cortical or cerebellum reference recorded for in control conditions with known light dark cycles and that loss<5%.

```{r SelectAnimalsChunk, echo=FALSE, include=TRUE}

Fig1SummaryDataframe<-filter(Fig1SummaryDataframe, Fig1_IISRate=="YES") #, LossIntervalPercentage<LossIntervalPercentageThreshold)



```


```{r CalculateMeanLossIntervalPercentage}
MeanLossIntervalPercentage<-mean(Fig1SummaryDataframe$LossIntervalPercentage)
```

Select for control/drug treatment condition
```{r SelectTreatmentCondition_Chunk, echo=FALSE}


SCPPDataframeControl<-filter(SCPPDataframeAll, Treatment=="Control")


```


## Compare SpikeCount Data between animals in control condition 
An average spike rate over the recording is not informative. The readout we use is number of spikes/8s interval which is the spikeCount variable in SCPPDataframe.


To compare between animals/genotypes, we use ECDF.
  iv. Create Data frame with empirical cumulative distribution for each animal in control conditions
```{r Create_ECDFs_chunk, echo=FALSE, include=FALSE}

ECDFAllCtrlDataframe<-data.frame()

for (j in 1:nrow(Fig1SummaryDataframe)){
  ECDFCurrent<-data.frame()
  #Select animalID for current loop
    AnimalIDCurrent<-Fig1SummaryDataframe$AnimalID[j]
  #Select genotype for current loop which will be used for ECDF plot
  GenotypeCurrent<-Fig1SummaryDataframe$Genotype[j]
  #Filter for control conditions for AnimalIDCurrent only 
  DataframeCurrent<-filter(SCPPDataframeControl, AnimalIDVariable==AnimalIDCurrent)
  
  #Create ECDF from current SCPP dataframe
  ECDFCurrent <-CreateECDF(DataframeCurrent, GenotypeCurrent, AnimalIDCurrent)
  #Save to dataframe for all animals to export
  ECDFAllCtrlDataframe<-rbind(ECDFAllCtrlDataframe, ECDFCurrent)
}

write.csv(ECDFAllCtrlDataframe, "./Output/ECDFAllCtrlDataframe.csv")
rm(ECDFCurrent, DataframeCurrent, SCPPDataframeControl)
```

Plot ECDF for all animals in control conditions

```{r ECDF_PlotChunk, echo=TRUE, include=TRUE} 

FontSize=10
ECDFAllCtrlPlot<-ggplot(ECDFAllCtrlDataframe, aes(x=SpikeCount, y=CumFrequency, color=AnimalIDVariable))
ECDFAllCtrlPlot<-ECDFAllCtrlPlot +
  geom_step() + 
  xlab("Number of spikes/8s") + 
  ylab("Cumulative frequency") + 
  facet_wrap(~Genotype) + 
  theme(legend.position = "none", 
        axis.text.x = element_text(size=FontSize),
        axis.text.y = element_text(size=FontSize),
        axis.title.x = element_text(size=FontSize),
        axis.title.y = element_text(size=FontSize))+
  scale_x_continuous(breaks=seq(0, 12, 2))


#http://blog.amitsharma.in/2015/09/13/cumulative-distribution-plots-for-frequency-Data-in-r/

ECDFAllCtrlPlot

ggsave("Output/Figures/Fig1/Fig1B.pdf", device="pdf", height = 6, width=8, units="cm")



```

To compare between genotypes, for each animal, we extract the proportion of intervals with more than 0 spikes and write it to Fig1SummaryDataframe as a new variable Grtr0Spikes.

``` {r ECDF_stats_chunk, ECHO=TRUE, include=TRUE}
#For each animal, evaluate the percentile of intervals with one or more spikes

#1-ECDFCurrent$CumFrequency[1] is the number of intervals with 1 or more spikes
for(i in 1:nrow(Fig1SummaryDataframe)){
  AnimalIDCurrent<-Fig1SummaryDataframe$AnimalID[i]
  ECDFCurrent<-filter(ECDFAllCtrlDataframe, AnimalIDVariable==AnimalIDCurrent)
  Fig1SummaryDataframe$Grtr0SpikeCtrl[i]<-1-(ECDFCurrent$CumFrequency[1]) 
}
Fig1SummaryDataframe

rm(ECDFCurrent, ECDFAllCtrlDataframe)
```



###Summary statistics for percentage intervals with 1 or more spikes
```{r SummaryStatsChunk, echo=FALSE, include=TRUE}


Fig1SummaryDataframe_WT<-filter(Fig1SummaryDataframe, Genotype=="WT")
Fig1SummaryDataframe_J20<-filter(Fig1SummaryDataframe, Genotype=="J20")

#Normality testing using Shapiro-Wilk and QQ plots

DataForTesting <-Fig1SummaryDataframe_WT$Grtr0SpikeCtrl
  SW_WT<-NormTesting(DataForTesting, "QQPlot_WT")
  SW_WT
  
DataForTesting <-Fig1SummaryDataframe_J20$Grtr0SpikeCtrl
  SW_J20<-NormTesting(DataForTesting, "QQPlot_J20")
  SW_J20
  
  #Summary statisitcs by genotype
SummaryStatsGrtr0Spikes<-SummarySE(Fig1SummaryDataframe, measurevar="Grtr0SpikeCtrl", groupvars=c("Genotype"), na.rm=TRUE)

SummaryStatsGrtr0Spikes$CI_L<-SummaryStatsGrtr0Spikes$Grtr0SpikeCtrl-SummaryStatsGrtr0Spikes$ci
SummaryStatsGrtr0Spikes$CI_U<-SummaryStatsGrtr0Spikes$Grtr0SpikeCtrl+SummaryStatsGrtr0Spikes$ci

SummaryStatsGrtr0Spikes
rm(DataForTesting, Fig1SummaryDataframe_J20, Fig1SummaryDataframe_WT)

```
###Mann-Whitney test to compare intervals with 1 or more spikes between genotypes

```{r Grtr0spike_Compare, echo=TRUE}



#Compare PercGreaterOneSpike in WT and J20

Data<-Fig1SummaryDataframe$Grtr0SpikeCtrl
Group<-Fig1SummaryDataframe$Genotype

WilcoxTestGrtr0Spike<-wilcox.test(Data~Group)
WilcoxTestGrtr0Spike
#Permutation tests, two-sided hypothesis, with 4 methods of sampling


#PermutationResults_exact.ce<-permTS(Data~Group,alternative="two.sided",method="exact.ce")
#PermutationResults_exact.mc<-permTS(Data~Group,alternative="two.sided",method="exact.mc")
#PermutationResults_exact.network<-permTS(Data~Group,alternative="two.sided",method="exact.network")
#PermutationResults_pclt<-permTS(Data~Group,alternative="two.sided",method="pclt")

#pCE<-PermutationResults_exact.ce$p.value
#pEMC<-PermutationResults_exact.mc$p.value
#pEN<-PermutationResults_exact.network$p.value
#pPCLT<-PermutationResults_pclt$p.value

#PrintVector<-data.frame("pCE"=pCE, "pEMC"=pEMC,"pEN"=pEN, "pCLT"=pPCLT)
#PrintVector

#rm(Data, Group, PermutationResults_exact.ce, PermutationResults_exact.mc, PermutationResults_exact.network, PermutationResults_pclt)

```
The number of intervals with one or more spikes was compared between genotypes using a permutation test. There was a significant difference between genotypes in the % intervals with 1 or more spikes:
`r PrintVector`)



###Plotting % intervals > 0 spikes
```{r ScatterPlotChunk, echo=FALSE}
Fig1SummaryDataframe$Genotype<-factor(Fig1SummaryDataframe$Genotype, levels = c("WT", "J20"))  #Need to reorder factor so that WT appears first in plot

FontSize<-10

Grtr0SpikePlot<- ggplot(Fig1SummaryDataframe, aes(x=Genotype, y=Grtr0SpikeCtrl))

Grtr0SpikePlot <- Grtr0SpikePlot+
  geom_point(size=2)+
  xlab("Genotype")+
  ylim(0, 0.2)+
  ylab("Prop intervals > 0 spikes")+
  theme(axis.text.x = element_text(size=FontSize),
        axis.text.y = element_text(size=FontSize),
        axis.title.x = element_text(size=FontSize),
        axis.title.y = element_text(size=FontSize))
 
Grtr0SpikePlot 

ggsave("Output/Figures/Fig1/Fig1C.pdf", device="pdf", width=4.5, height = 5, units="cm")

```


Write Fig1 Summaries
```{r WriteFig1Summary, echo=FALSE}
write.csv(Fig1SummaryDataframe, "Fig1SummaryDataframe.csv")

```
#########################################################################
#Figure 2: IIS and time of day
Figure 2A: Example of circadian fluctuations in IIS from JF167

It has been suggested that seizure-related activity varies across the circadian cycle {Quigg:2000vq}. Looking at IIS times across several days suggested that IIS the IIS counts vary across the circadian cycle â€“ with IIS occurring more frequently in the inactive phase (Fig 2A).

Plot example of circadian spike probability for JF167
```{r Fig2AIISTimesExample, echo=FALSE}


#Filter SCPP1DataFrameAll to select for JF152 
IISTimesExample<-filter(SCPPDataframeAll, AnimalIDVariable=="JF152", Treatment=="Control")
# Select the relevant columns of dataframe
IISTimesExample<-dplyr::select(IISTimesExample, SpikeCount, TimeOfDay)
#Filter for intervals with >0 IIS
IISTimesExample<-filter(IISTimesExample, SpikeCount>0)
#Convert the to Posixlt format
IISTimesExample$TimeOfDay<-strptime(IISTimesExample$TimeOfDay, "%Y-%m-%d %H:%M:%S")


## extract hour of IIS with lubridate function
IISTimesExample$hour_of_event <- hour(IISTimesExample$TimeOfDay)
# make a new dataframe with hour appended
EventData <- data.frame(DateTime = IISTimesExample$TimeOfDay, EventHour = IISTimesExample$hour_of_event)
# determine if event is in light hours
EventData$Light <- EventData$EventHour %in% seq(7, 18)

  #Shift the event hour by 0.5 because having interger times was giving binning problems at 0 bins
    EventData$EventHourShifted<-EventData$EventHour+0.5


#Make circular plot
fontsize=10

Fig2A<-ggplot(EventData, aes(x = EventHourShifted, fill = Light)) +
  geom_histogram(breaks = seq(0,   24), binwidth = 2, colour = "grey") + 
  coord_polar(start = 0) + 
  theme_minimal() + 
  scale_fill_grey(start=0.1, end=0.9, labels=c("Off", "On")) + 
  ylab("Count") + 
  ggtitle("IIS by Time of day") + 
  theme(plot.title = element_text (size = fontsize))+
  theme(axis.title.y=element_text (size = fontsize))+
  theme(axis.text.y =element_text (size = fontsize))+
  theme(axis.text.x =element_text (size = fontsize))+
  scale_x_continuous("", limits = c(0, 24), breaks = seq(0, 24, 2), labels = seq(0,24, 2))+
  theme(panel.grid.minor =   element_line(colour = "grey40",size=0.2),
        panel.grid.major =   element_line(colour = "grey40",size=0.2))


print(Fig2A)

ggsave("Output/Figures/Fig2/Fig2A.pdf", device="pdf")
rm(IISTimesExample, EventData)
```

Figure 2B:
We used circular statistics to establish whether IIS were significantly-coupled to a phase of the circadian cycle within individual animals (Fig 2A, see methods). 

###1. Create Fig2SummaryDataframe from recordingInformation. 
```{r create_fig2_dataframe, ECHO=FALSE, include=FALSE}
  Fig2SummaryDataframe <- SummaryDataframe[, c("AnimalID", "Genotype", "TimeZone", "Fig2_CircadianCoupling", "LossIntervalPercentage", "Protocol")]
#Remove rows with missing variables
  Fig2SummaryDataframe <- Fig2SummaryDataframe[complete.cases(Fig2SummaryDataframe),]
```
  
2. Select animals that will be used in the analysis: animals with cortical or cerebellum reference recorded for in control conditions with known light dark cycles. J20 only
```{r SelectAnimalsChunk, echo=FALSE, include=TRUE}


Fig2SummaryDataframe<-filter(Fig2SummaryDataframe, Fig2_CircadianCoupling=="YES")

#Filter for Loss <5%
Fig2SummaryDataframe<-filter(Fig2SummaryDataframe, LossIntervalPercentage<LossIntervalPercentageThreshold)

```

Select for control/drug treatment condition
```{r SelectTreatmentCondition_Chunk, echo=FALSE}


SCPPDataframeControl<-filter(SCPPDataframeAll, Treatment=="Control")


```

  
  
###2. Calculate summary statistics for all animals
```{r Fig2BCircularStatsSummary}
# Select the relevant columns of dataframe
IISTimes<-select(SCPPDataframeControl, SpikeCount, InitialisedTime, 
                 TimeOfDay,Treatment, AnimalIDVariable)

#Filter for intervals with >0 IIS
IISTimes<-filter(IISTimes, SpikeCount>0)
#Convert all IIS times to radian angles
IISTimes$IISAngles<-ConvertToRadians(IISTimes$InitialisedTime)


  
#For each animalID, calculate summary stats and write to Fig2SummaryStats
for(i in 1:nrow(Fig2SummaryDataframe)){
  AnimalIDCurrent<-Fig2SummaryDataframe$AnimalID[i]
  IISTimesCurrent<-filter(IISTimes, AnimalIDVariable==AnimalIDCurrent)
  SummaryCircStatsCurrent<-SummaryCircStats(IISTimesCurrent$IISAngles)
  
  #Write summary circular stats to Fig2SummaryDataframe
  Fig2SummaryDataframe$MeanAngle[i]<-SummaryCircStatsCurrent$MeanAngle[1]
  Fig2SummaryDataframe$Rho[i]<-SummaryCircStatsCurrent$Rho[1]
  Fig2SummaryDataframe$SDAngle[i]<-SummaryCircStatsCurrent$SDAngle[1]
  Fig2SummaryDataframe$RayleighR[i]<-SummaryCircStatsCurrent$RayleighR[1]
  Fig2SummaryDataframe$RayleighP[i]<-SummaryCircStatsCurrent$RayleighP[1]
  AnimalIDCurrent<-c()
  IISTimesCurrent<-c()
  SummaryCircStatsCurrent<-c()
  
  #Convert from radians to time
  Fig2SummaryDataframe$MeanTimeSecs<-ConvertToSeconds(Fig2SummaryDataframe$MeanAngle)
  Fig2SummaryDataframe$SDSecs<-ConvertToSeconds(Fig2SummaryDataframe$SDAngle)
#Convert from unix time to time of day
  TempTimeDataframe<-ConvertUnixSecondsToTimeOfDay(Fig2SummaryDataframe$MeanTimeSecs)
  Fig2SummaryDataframe$MeanDateTime<-TempTimeDataframe$TimeOfDay
  Fig2SummaryDataframe$MeanTimeSeconds<-TempTimeDataframe$TimeOfDayTimeFormat

  #Calculate number of J20s that showed significant phasecoupling
  Fig2SummaryDataframe_J20<-filter(Fig2SummaryDataframe, Genotype=="J20")
  
}
rm(TempTimeDataframe, SCPPDataframeControl, AnimalIDCurrent,IISTimesCurrent,SummaryCircStatsCurrent)
```


```{r SampleSummaryStats, echo=FALSE, include=FALSE}
SampleMeanAngle<-mean.circular(Fig2SummaryDataframe_J20$MeanAngle)
if(SampleMeanAngle<0){
  SampleMeanAngle<-SampleMeanAngle+(2*pi)
}
SampleMeanTimeSeconds<-ConvertToSeconds(SampleMeanAngle)
SampleMeanDateTime<-ConvertUnixSecondsToTimeOfDay(SampleMeanTimeSeconds)

SampleMeanDeviation<-meandeviation(Fig2SummaryDataframe_J20$MeanAngle)

SampleRayleighP<-rayleigh.test(Fig2SummaryDataframe_J20$MeanAngle)

```
Across the sample of J20s, the IIS was significantly coupled to light periods (Phi_J20=`r SampleMeanDateTime$TimeOfDay`), Rho_J20=`r SampleMeanDeviation`, RayleighP_J20=`r SampleRayleighP`.


###3. Plot polar histograms for all J20s
```{r SpikeHist_Chunk, echo=FALSE}
dir.create("./Output/SpikeHists")

for(i in 1:nrow(Fig2SummaryDataframe_J20)){
    AnimalIDCurrent=Fig2SummaryDataframe_J20$AnimalID[i]
    #Filter SCPP1DataFrameAll to select for JF167 
    IISTimesCurrent<-filter(SCPPDataframeAll, AnimalIDVariable==AnimalIDCurrent)
    # Select the relevant columns of dataframe
    IISTimesCurrent<-dplyr::select(IISTimesCurrent, SpikeCount, TimeOfDay)
    #Filter for intervals with >0 IIS
    IISTimesCurrent<-filter(IISTimesCurrent, SpikeCount>0)
    #Convert the to Posixlt format
    IISTimesCurrent$TimeOfDay<-strptime(IISTimesCurrent$TimeOfDay, "%Y-%m-%d %H:%M:%S")
    
    
    ## extract hour of IIS with lubridate function
    IISTimesCurrent$hour_of_event <- hour(IISTimesCurrent$TimeOfDay)
    # make a new dataframe with hour appended
    EventData <- data.frame(DateTime = IISTimesCurrent$TimeOfDay, EventHour = IISTimesCurrent$hour_of_event)
    # determine if event is in light hours
    EventData$Light <- EventData$EventHour %in% seq(7, 18)
    
   
    
    #Shift the event hour by 0.5 because having interger times was giving binning problems at 0 bins
    EventData$EventHourShifted<-EventData$EventHour+0.5
    
    #Make circular plot
    fontsize=10
    #Filename for saving
    names<-Fig2SummaryDataframe_J20$AnimalID
    filename<-paste("./Output/SpikeHists/", names[i],"_SpikeHist",".pdf", sep="")
    
    SpikeHist<-ggplot(EventData, aes(x = EventHourShifted, fill = Light)) +
      geom_histogram(breaks = seq(0,   24), binwidth = 2, colour = "grey") +   coord_polar(start = 0) + 
      theme_minimal() + 
      scale_fill_grey(start=0.1, end=0.9, labels=c("Off", "On")) + 
      ylab("Count") + 
      ggtitle(paste(AnimalIDCurrent, as.character(round(Fig2SummaryDataframe$RayleighP[i], 3)), as.character(round(Fig2SummaryDataframe$RayleighR[i], 3)))) + 
      theme(plot.title = element_text (size = fontsize))+
      theme(axis.title.y=element_text (size = fontsize))+
      theme(axis.text.y =element_text (size = fontsize))+
      theme(axis.text.x =element_text (size = fontsize))+
      scale_x_continuous("", limits = c(0, 24), breaks = seq(0, 24, 2), labels = seq(0,24, 2))+
  theme(panel.grid.minor =   element_line(colour = "grey40",size=0.2),
        panel.grid.major =   element_line(colour = "grey40",size=0.2))

    
    
    
    ggsave(file=filename, device="pdf")
}

rm(IISTimesCurrent, IISTimes, EventData)
```

###4. Determine phase coupling of strength and compare between WT and J20. Hypothesis testing
To quantify the coupling of IIS to the day-night cycle, we calculated the circular mean angle and dispersion, and Rayleigh probability for all J20s.

```{r J20SampleRho, echo=FALSE, include=FALSE}

#t-test to get CI
MeanRho<-mean(Fig2SummaryDataframe_J20$Rho, na.rm=TRUE)
SDRho<-sd(Fig2SummaryDataframe_J20$Rho, na.rm=TRUE)
tRho<-t.test(Fig2SummaryDataframe_J20$Rho)
CIRho<-tRho$conf.int



```


`r sum(Fig2SummaryDataframe_J20$RayleighP<0.05)` of `r nrow(Fig2SummaryDataframe_J20)` ) animals exhibited significant phase coupling of IIS as estimated by the Rayleigh test (p=(`r min(Fig2SummaryDataframe_J20$RayleighP) -- max(Fig2SummaryDataframe_J20$RayleighP)`. The degree of phase coupling varied between animals as can be seen in the distribution of the angular dispersion, rho= `r round(MeanRho, 2)` 95%CI=`r CIRho[[1]]`, `r CIRho[[2]]`) .

Range Rho=(`r min(Fig2SummaryDataframe_J20$RayleighR)`, `r max(Fig2SummaryDataframe_J20$RayleighR)`)



```{r PolarPlotRhoMeanAngleJ20, echo=FALSE, include=FALSE}
radial.plot(Fig2SummaryDataframe_J20$Rho,
                                Fig2SummaryDataframe_J20$MeanAngle,
                                start=(pi/2), clockwise = TRUE,
                                labels=c("0/24h","6h", "12h", "18h"),
                                label.pos = c(0, (pi/2), pi, (3*pi/2)), 
                                label.prop=1.4, rp.type = "s",
                                point.symbols = 20, 
                                cex=2.5,
                                show.radial.grid = TRUE, 
                                radial.lim = c(0, 0.5,1))

#print(SampleRhoMeanAngle)

filename<-"./Output/Figures/Fig2/Fig2B.pdf"

pdf(file=filename)
radial.plot(Fig2SummaryDataframe_J20$Rho,
                                Fig2SummaryDataframe_J20$MeanAngle,
                                start=(pi/2), clockwise = TRUE,
                                labels=c("0/24h","6h", "12h", "18h"),
                                label.pos = c(0, (pi/2), pi, (3*pi/2)), 
                                label.prop=2, rp.type = "s",
                                point.symbols = 20, 
                                cex=2.5,
                                show.radial.grid = TRUE, 
                                radial.lim = c(0,0.5,1) 
              )


dev.off()



#Saved file does not have x-axis labels. NEED TO FIX THIS 13/07/17

```



We identify circular outliers using Abuzaid et al 2010 J Stat Comp Sim
```{r CircularOutliers, echo = TRUE, include = TRUE}
AngleNew<-Fig2SummaryDataframe_J20$MeanAngle-2*pi
Outliers<-Huberized(AngleNew)
```

Set Circular Outliers
```{r SetCircularOutlier, echo=TRUE, include=TRUE}
OutliersIndex<-c()
CircularOutliers<-c(1, 4, 15, 16) #From Huberized
Fig2SummaryDataframe_J20$Outliers<-0
Fig2SummaryDataframe_J20$Outliers[CircularOutliers]<-1
CircularOutliersAnimalID<-Fig2SummaryDataframe_J20$AnimalID[CircularOutliers]
for(i in 1:length(CircularOutliers)){
  OutliersIndex[i]<-which(SummaryDataframe$AnimalID==CircularOutliersAnimalID[i])
}

SummaryDataframe$Outliers<-0
SummaryDataframe$Outliers[OutliersIndex]<-1


```


```{r WriteFig2Summaries, echo=FALSE}
write.csv(SummaryDataframe, "Output/SummaryDataframe.csv")

write.csv(Fig2SummaryDataframe_J20, "Output/Fig2SummaryDataframe_J20.csv")

write.csv(Fig2SummaryDataframe, "Output/Fig2SummaryDataframe.csv")

```

#########
###Relate spike count to recording protocol
We want to ask whether the poor phase coupling can result from time after surgery. C= 3 day continuous recording protocol. B=Broken protocol with recordings on days 1, 5,6
```{r RhoVsProtocolGrp, include=TRUE, echo=FALSE}
RhoProtocolPlot<-ggplot(Fig2SummaryDataframe_J20, 
                        aes(x=Protocol, 
                            y=Rho))+
  geom_point()

RhoProtocolPlot


```





#########################################################################
##Figure 3/4: Probability of IIS and behavioral state
Since IIS occurred preferentially in the light, we hypothesised that IIS occur preferentially during sleep. Analyse spikes with scored video data

1. Import VideoTimes.csv
```{r ImportVideoTimes, echo=FALSE, include=False}
VideoTimesFilename<-"./Data/VideoTimesSummary.csv"
VideoTimes<-read.csv(VideoTimesFilename)
TempTimes<-strptime(as.character(VideoTimes$VideoStartTime), "%d/%m/%Y %H:%M:%S")
VideoTimes$VideoStartTimeLinux<-(as.numeric(as.POSIXct(TempTimes)))

TempTimes<-strptime(as.character(VideoTimes$VideoEndTime), "%d/%m/%Y %H:%M:%S")
VideoTimes$VideoEndTimeLinux<-(as.numeric(as.POSIXct(TempTimes)))

```




3. Import VideoScoring dataframe and amend with UnixTime 
```{r MakeVideoScoringDataframe, echo=FALSE, include=FALSE}

FileList<-c("./Data/VideoScoring/VideoScoringJF220_040416.csv",
            "./Data/VideoScoring/VideoScoringJF220_050416.csv",   
            "./Data/VideoScoring/VideoScoringJF220_060416.csv",  
            "./Data/VideoScoring/VideoScoringJF220_070416.csv",
            "./Data/VideoScoring/VideoScoringJF220_080416.csv", 
           "./Data/VideoScoring/VideoScoringJ0373_030816Day.csv",
            "./Data/VideoScoring/VideoScoringJ0373_030816Night.csv",
            "./Data/VideoScoring/VideoScoringJ0375_120816Day.csv",
            "./Data/VideoScoring/VideoScoringJ0375_120816Night.csv",
            "./Data/VideoScoring/VideoScoringJ0376_140816Day.csv",
            "./Data/VideoScoring/VideoScoringJF221_040416.csv",
            "./Data/VideoScoring/VideoScoringJF221_050416.csv",
            "./Data/VideoScoring/VideoScoringJF221_060416.csv",
            "./Data/VideoScoring/VideoScoringJF221_080416.csv",
           "./Data/VideoScoring/VideoScoringJ0456_260417.csv",
          "./Data/VideoScoring/VideoScoringJ0460_210517.csv"
          )


AnimalIDList<-c("JF220", "JF220", "JF220", "JF220", "JF220",
               "J0373", "J0373",
              "J0375", "J0375", 
              "J0376", 
              "JF221", "JF221", 
             "JF221", "JF221", 
             "J0456", "J0460"
            )
SCPPDataframeVideoTimesAll<-data.frame()
AnimalIDVideoStartEnd<-list() #A list to store Start and End times for video data. The list index is AnimalID_FileIndex eg. JF220_1

for(FileIndex in 1:length(FileList)){
   # VideoScoringFilename<-"./Data/VideoScoringJF220_040416.csv"
   VideoScoringFilename<-FileList[[FileIndex]] 
   #Date<-DateList[[FileIndex]]
   AnimalIDCurrent<-AnimalIDList[[FileIndex]]
   
    #Import
    VideoScoring<- read.csv(VideoScoringFilename)
    VideoScoring<-dplyr::select(VideoScoring, DateOfEEG, TimeOfEEG,  SleepWake)
    VideoScoring$SleepWake<-as.character(VideoScoring$SleepWake) #needs to be character. "as.factor" converts to numeric factors
    
    #Add date to Time to make TimeString
    VideoScoring$DateTime<-paste(VideoScoring$DateOfEEG, VideoScoring$TimeOfEEG)
    
    VideoScoring$DateTime<-strptime(as.character(VideoScoring$DateTime), "%d/%m/%Y %H:%M:%S")
    
    #Convert to UnixTime
    VideoScoring$UnixTime<-(as.numeric(as.POSIXct(VideoScoring$DateTime)))
    #VideoScoring<-VideoScoring[complete.cases(VideoScoring)]
    #Determine Start and End time of video file for particular day
    VideoStartTime<-VideoScoring$UnixTime[1]
    VideoEndTime<-VideoScoring$UnixTime[nrow(VideoScoring)]
    
    #Create vector with videostart and videoend variables for this FileIndex iteration
    AnimalIDVideoStartEndVectorCurrent<-c(as.numeric(VideoStartTime), as.numeric(VideoEndTime))
    
    ListIndex<-paste(AnimalIDCurrent, as.character(FileIndex), sep="_")
    AnimalIDVideoStartEnd[[ListIndex]]<-AnimalIDVideoStartEndVectorCurrent
    
    #Filter SCPP1 between start and endtime of video for particular day

  SCPPDataframeVideoTimes<-filter(SCPPDataframeAll,
                                  AnimalIDVariable==AnimalIDCurrent)
  SCPPDataframeVideoTimes<-filter(SCPPDataframeVideoTimes,
                                  InitialisedTime>=VideoStartTime)
    SCPPDataframeVideoTimes<-filter(SCPPDataframeVideoTimes, InitialisedTime<=VideoEndTime)
    
    
    #Add video score to dataframe for which video is available
    
    SCPPDataframeVideoTimes$SleepWake<-AddVideoScoreToSCPPData(SCPPDataframeVideoTimes$InitialisedTime, VideoScoring$UnixTime, VideoScoring$SleepWake)
    SCPPDataframeVideoTimesAll<-rbind(SCPPDataframeVideoTimesAll, SCPPDataframeVideoTimes)
  
    SCPPDataframeVideoTimesAll$SleepWake<-as.factor(SCPPDataframeVideoTimesAll$SleepWake)
}

rm(SCPPDataframeVideoTimes, VideoScoring, VideoTimes)
```


5. Plot theta/delta and sleep wake against time. The chunk iterates through all animals and saves output plots into folder ./Output/ThetaDeltaBehavioralState

```{r, PlotThetaDeltaSW_all, echo=FALSE, include=FALSE}

      for(FileIndex in 1:length(AnimalIDVideoStartEnd)){ #Loop through all video files from video start to end and plot
        AnimalIDCurrent<-AnimalIDList[[FileIndex]]
        ListID<-paste(AnimalIDCurrent, as.character(FileIndex), sep="_")
      
      ThetaPlot<-ggplot(filter(SCPPDataframeVideoTimesAll, AnimalIDVariable==AnimalIDCurrent), aes(x=InitialisedTime, y=Theta))+geom_point()+xlim(AnimalIDVideoStartEnd[[ListID]])+ylim(0,100)+ggtitle(ListID)
      
      DeltaPlot<-ggplot(filter(SCPPDataframeVideoTimesAll, AnimalIDVariable==AnimalIDCurrent), aes(x=InitialisedTime, y=Delta))+geom_point()+xlim(AnimalIDVideoStartEnd[[ListID]])+ylim(0,200)
      
      ThetaOverDeltaPlot<-ggplot(filter(SCPPDataframeVideoTimesAll, AnimalIDVariable==AnimalIDCurrent), aes(x=InitialisedTime, y=ThetaOverDelta))+geom_point()+xlim(AnimalIDVideoStartEnd[[ListID]])+ylim(0, 5)
      
      SpikeCountPlot<-ggplot(filter(SCPPDataframeVideoTimesAll, AnimalIDVariable==AnimalIDCurrent), aes(x=InitialisedTime, y=SpikeCount))+geom_point()+xlim(AnimalIDVideoStartEnd[[ListID]])+ylim(0, 5)
      
      SleepWakePlot<-ggplot(filter(SCPPDataframeVideoTimesAll,
                               AnimalIDVariable==AnimalIDCurrent),
                        aes(x=InitialisedTime,
                            y=SleepWake)) + 
        geom_point()+
        xlim(AnimalIDVideoStartEnd[[ListID]])
      
      
      FileName<-paste("./Output/ThetaDeltaBehaviouralState/", "ThetaDeltaBehaviouralState",ListID,".pdf", sep="")

    PlotGridSave<-plot_grid(ThetaPlot, DeltaPlot, ThetaOverDeltaPlot, SpikeCountPlot, SleepWakePlot, align = "v", nrow = 5)
  
 if(dir.exists("./Output/ThetaDeltaBehaviouralState")==FALSE) {
   dir.create("./Output/ThetaDeltaBehaviouralState")
 }
  pdf(file=FileName)
  print(PlotGridSave)
  dev.off()
      
}

```


######
Sleep wake example

```{r SleepWakeExample, include=TRUE, echo=FALSE}
PtSize<-0.5
FontSize<-10

AnimalID<-"JF220"
StartTime<-AnimalIDVideoStartEnd$JF220_3[[1]]
EndTime<-AnimalIDVideoStartEnd$JF220_3[[2]]
SleepWakeSpikeCountData<-filter(SCPPDataframeVideoTimesAll, InitialisedTime>StartTime & InitialisedTime<EndTime)
SleepWakeSpikeCountData$ZeroTime<-SleepWakeSpikeCountData$InitialisedTime-min(SleepWakeSpikeCountData$InitialisedTime)
SleepWakeSpikeCountData$PerSec<-SleepWakeSpikeCountData$SpikeCount/8
SleepWakeSpikeCountPlot<-ggplot(SleepWakeSpikeCountData,
                                aes(x=ZeroTime, 
                                    y=SpikeCount,
                                    color=SleepWake)) +
  scale_colour_grey() +
  geom_point(size=PtSize) +
  xlab("Time (s)") +
  ylab("Spike Count/8s")+
  ylim(c(0,4))+
  xlim(c(0, 7200))+
  theme(axis.text.x = element_text(size=FontSize),
        axis.text.y = element_text(size=FontSize),
        axis.title.x = element_text(size=FontSize),
        axis.title.y = element_text(size=FontSize))

SleepWakeSpikeCountPlot

ggsave("Output/Figures/Fig3/Fig3A.pdf", device="pdf", width=10, height=5, units="cm")
rm(SleepWakeSpikeCountData)
```


IIS occurred in the light hours, we wanted to ask whether IIS are more prevalent in specific brain states. To this end, we used the theta signal to characterise epochs as sleep/wake and asked whether p(IIS|S)>p(IIS|W)

```{r, SWPlottingChunk, include=TRUE, echo=FALSE}
#if("plyr" %in% (.packages())){
 # detach("package:plyr", unload=TRUE)
#}
#Group by AnimalID and SleepWake
SW_grouped<-dplyr::group_by(SCPPDataframeVideoTimesAll, AnimalIDVariable, SleepWake)
#Compute the mean spike rate for each animal in each behavioural state                     
SummarySW<-dplyr::summarise(SW_grouped,
                     MeanSpikeRate=mean(SpikeCount)/8,
                     num=n(),
                     SEM=sd(SpikeCount)/sqrt(n()),
                     CI_L=CI(SpikeCount)[1]/8,
                     CI_U=CI(SpikeCount)[3]/8, 
                     SleepWakeFull=if(SleepWake=="S") "Sleep" else "Wake")
PhaseCoupling<-c(rep("Weak", 4), rep("Strong", 4))
SummarySW$PhaseCoupling<- PhaseCoupling

#Plot summary plot of mean spike rate
#SWPlot<-ggplot(SummarySW, 
#               aes(x=SleepWake, 
#                   y=MeanSpikeRate, 
#                   group=AnimalIDVariable)) +
#  geom_line(aes(color=AnimalIDVariable)) +
#  geom_point(aes(color=AnimalIDVariable)) +
#  geom_errorbar(aes(ymin=MeanSpikeRate, ymax=MeanSpikeRate+SEM))+
#  ylab("Mean spike/s") +
#  xlab("Behavioural State")

SWPlot<-ggplot(SummarySW, 
               aes(x=SleepWakeFull, 
                   y=MeanSpikeRate)) +
              facet_grid(.~PhaseCoupling) +
  geom_line(aes(group=AnimalIDVariable)) +
  geom_point(aes(group=AnimalIDVariable)) +
  geom_errorbar(aes(ymin=CI_L, ymax=CI_U, width=0.4))+
  ylab("Mean spike/s") +
  xlab("Behavioural State") +
  theme(legend.position = "none") +
  theme(axis.text.x = element_text(angle=60, hjust=1))#+
  #scale_color_brewer(palette = "Set1")


SWPlot

ggsave("Output/Figures/Fig3/Fig3B.pdf", device="pdf", width=8, height=5, units="cm")


#rm(SCPPDataframeVideoTimesAll)

```
######################################
####Fig 4 IIS and theta/delta
Theta/delta ratios have been used to characterise sleep stages (Ewell et al 2016) and seizures were shown to be more prevalent following REM. We thus asked whether IIS were more prevalent during periods of elevated Theta/Delta.
p(IIS|theta/delta>threshold)


Example of theta/delta and spike count for J20
```{r SpikeCountThetaDeltaExample, echo=FALSE}

AnimalIDCurrent<-"JF220"
StartTime<-AnimalIDVideoStartEnd$JF220_1[[1]]
EndTime<-AnimalIDVideoStartEnd$JF220_1[[2]]

SleepWakeSpikeCountData<-filter(SCPPDataframeVideoTimesAll, InitialisedTime>StartTime & InitialisedTime<EndTime)


SleepWakeSpikeCountData$ZeroTime<-SleepWakeSpikeCountData$InitialisedTime-min(SleepWakeSpikeCountData$InitialisedTime)
#SleepWakeSpikeCountData$PerSec<-SleepWakeSpikeCountData$SpikeCount/8

SleepWakeSpikeCountData$ThetauVolts<-SleepWakeSpikeCountData$Theta*160


SleepWakeSpikeCountData$DeltauVolts<-SleepWakeSpikeCountData$Delta*160

PtSize=0.5
FontSize=10

SleepWakeSpikeCountPlot<-ggplot(SleepWakeSpikeCountData,
                                aes(x=ZeroTime, 
                                    y=SpikeCount,
                                    color=SleepWake)) +
  scale_colour_grey() +
  geom_point(size=PtSize) +
  xlab("Time (s)") +
  ylab("Spikes/8s")+
  scale_y_continuous(limits=c(0,8), breaks=seq(0, 8, 4))+
  xlim(c(0, 7200))+
  theme(legend.position = "none")+
  theme(axis.text.x = element_text(size=FontSize),
        axis.title.x = element_text(size=FontSize),
        axis.text.y = element_text(size=FontSize),
        axis.title.y = element_text(size=FontSize))

       
      
      ThetaPlot<-ggplot(SleepWakeSpikeCountData, 
                        aes(x=ZeroTime, 
                            y=ThetauVolts, 
                            color=SleepWake)) +
        scale_colour_grey() +
        geom_point(size=PtSize) + 
        scale_y_continuous(limits=c(0,20000), breaks=seq(0, 20000, 10000))+
        xlab("Time (s)") +
  ylab(expression(paste(theta, " (", mu, V^{2}, ")"))) +
  xlim(c(0, 7200))+ 
        theme(axis.title.x=element_blank(), 
              axis.text.x=element_blank(), 
              axis.ticks.x = element_blank(), 
              legend.position = "none")+
        theme(axis.text.y = element_text(size=FontSize),
        axis.title.y = element_text(size=FontSize))
      
      
      DeltaPlot<-ggplot(SleepWakeSpikeCountData, 
                        aes(x=ZeroTime, 
                            y=DeltauVolts, 
                            color=SleepWake)) +
        scale_colour_grey() +
        geom_point(size=PtSize)+
        ylab(expression(paste(delta, " (", mu, V^{2}, ")"))) +
        scale_y_continuous(limits=c(0,40000), breaks=seq(0, 40000, 20000))+
        xlim(c(0, 7200))+
        theme(axis.title.x=element_blank(), 
              axis.text.x=element_blank(), 
              axis.ticks.x = element_blank(), 
              legend.position = "none")+
      theme(axis.text.y = element_text(size=FontSize),
        axis.title.y = element_text(size=FontSize))
      
      ThetaOverDeltaPlot<-ggplot(SleepWakeSpikeCountData, 
                                 aes(x=ZeroTime, 
                                     y=ThetaOverDelta, 
                                     color=SleepWake)) +
        scale_colour_grey() +
        geom_point(size=PtSize) +
        scale_y_continuous(limits=c(0,5), breaks=seq(0, 5, 2.5))+
        ylab(expression(paste(theta, "/", delta)))+
        xlim(c(0, 7200))+
        theme(axis.title.x=element_blank(), 
              axis.text.x=element_blank(), 
              axis.ticks.x = element_blank(), 
              legend.position = "none")+
        theme(axis.text.y = element_text(size=FontSize),
        axis.title.y = element_text(size=FontSize))
      
      
      
     

    SleepWakeThetaDelta<-plot_grid(DeltaPlot,ThetaPlot,  ThetaOverDeltaPlot,SleepWakeSpikeCountPlot,  align = "v", nrow = 4, rel_heights = c(1,1,1,1.4))
  
 SleepWakeThetaDelta
 
ggsave("Output/Figures/Fig4/Fig4A.pdf",device="pdf",  width=8, height=12, units="cm")      


```


```{r create_fig3_dataframe, ECHO=FALSE}
  Fig4SummaryDataframe<-SummaryDataframe[, c("AnimalID", "Genotype", "TimeZone", "DrugDateTime", "Fig4_BrainState", "LossIntervalPercentage")]
#Remove rows with missing variables
  Fig4SummaryDataframe<-Fig4SummaryDataframe[complete.cases(Fig4SummaryDataframe),]
```
  
2. Select animals that will be used in the analysis cerebellum reference recorded for in control conditions with known light dark cycles.
```{r SelectAnimalsChunk, echo=FALSE, include=TRUE}

Fig4SummaryDataframe<-filter(Fig4SummaryDataframe, Fig4_BrainState=="YES", Genotype=="J20", LossIntervalPercentage<LossIntervalPercentageThreshold  )

```

3. For each animal to include, in control conditions: calculate theta/delta for 0 or > 0 spikes
```{r, ThetaOverDeltaBySpikeNumChunk, echo=FALSE, include=TRUE}
 
SCPPDataframeControl<-dplyr::filter(SCPPDataframeAll, Treatment=="Control") 

ThetaDeltaGrouped<-dplyr::group_by(SCPPDataframeControl, AnimalIDVariable, SpikeCount)
#Compute the mean spike rate for each animal in each behavioural state                     
SummaryThetaDelta<-dplyr::summarise(ThetaDeltaGrouped, MeanThetaDelta=mean(ThetaOverDelta, na.rm = TRUE),
                             CI_L=Rmisc::CI(ThetaOverDelta)[1],
                             CI_U=Rmisc::CI(ThetaOverDelta)[3])
SummaryThetaDelta<-dplyr::filter(SummaryThetaDelta, AnimalIDVariable %in% Fig4SummaryDataframe$AnimalID)
SummaryThetaDelta$Coupling<-ifelse((SummaryThetaDelta$AnimalIDVariable=="J0456"|SummaryThetaDelta$AnimalIDVariable=="J0460"),"Weak", "Strong")
SummaryThetaDelta
  
ThetaDeltaSpikePlot<-ggplot(SummaryThetaDelta, 
                            aes(x=SpikeCount,
                                y=MeanThetaDelta, 
                                group=AnimalIDVariable)) +
  geom_line(aes(colour=AnimalIDVariable))+
  geom_point(aes(colour=AnimalIDVariable, shape=Coupling)) +
  geom_errorbar(aes(ymin=CI_L, ymax=CI_U, colour=AnimalIDVariable)) +
  scale_x_continuous(name = "Spike Count/8s", breaks=seq(0,12,2)) +
  scale_shape_manual(values=c(16,1))+
  theme(legend.position = c(0.7, 0.9), 
        axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=10), 
        axis.title.x = element_text(size=10),
        axis.title.y = element_text(size=10), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        panel.background = element_blank(), 
        axis.line = element_line(colour="black")) +
  ylab(expression(paste(theta, "/", delta))) +
  scale_color_brewer(palette="Set1", guide=FALSE) +
  ylim(0, 3)

ThetaDeltaSpikePlot

ggsave("Output/Figures/Fig4/Fig4B.pdf", device="pdf", height=6, width=8, units="cm")

rm(ThetaDeltaGrouped)

```
Export for GLME and MCMC analysis
```{r ExportForGLME_MCMC, echo=FALSE}
#This chunk exports the data, for 5 animals with CBLM reference, loss and artifacts excluded, in control conditions to csv for Crispin to analyse 
SpikesThetaDeltaExport<-dplyr::select(SCPPDataframeControl, SpikeCount, ThetaOverDelta, AnimalIDVariable, InitialisedTime)
SpikesThetaDeltaExport<-dplyr::filter(SpikesThetaDeltaExport, AnimalIDVariable %in% Fig4SummaryDataframe$AnimalID)
write.csv(SpikesThetaDeltaExport, "Output/SpikesThetaDeltaExport.csv")
rm(SpikesThetaDeltaExport)


```
Stats for theta/delta and IIS
```{r SpikesCountBinaryThetaDeltaLMM, include=TRUE, echo=FALSE}

ThetaDeltaLMEDataframe<-filter(SCPPDataframeControl, AnimalIDVariable %in% Fig3SummaryDataframe$AnimalID)

ThetaDeltaLMEDataframe<-mutate(ThetaDeltaLMEDataframe,SpikesBinary=if_else(SpikeCount>0, "M", "Z")) #SpikesBinary: >1 = "M"ore/ 0 = "Z"ero

SpikesBinary.model<-lmer(ThetaOverDelta~ SpikesBinary + (1|AnimalIDVariable), data=ThetaDeltaLMEDataframe, REML = FALSE)

#Plot residuals
plot(fitted(SpikesBinary.model), residuals(SpikesBinary.model))

summary(SpikesBinary.model)


#Test signficance of SpikesBinary fixed effect using a chi-squared statistic
SpikesBinary.null<-lmer(ThetaOverDelta~ (1|AnimalIDVariable), data=ThetaDeltaLMEDataframe, REML = FALSE)
anova(SpikesBinary.model, SpikesBinary.null)

rm(SCPPDataframeControl, ThetaDeltaLMEDataframe)
```

###Event-triggered averages of theta/delta 
Event times are used for an event-triggered average for +-80s around interval of event. The output of the chunk is ETList with 2 list elements per AnimalID. ETList$ETAv for that animal is event triggered average; ETList$ETW is the list of each individual event triggered window. List elements for ETW are $TriggeredWindowTime and $TriggeredWindowData.

```{r EventTriggeredAveragingOfThetaDelta, echo=FALSE, include=TRUE}

#This chunk has been tested using the following test ETAvTest,R
ETAvFilename<-"Ouput/ETAvDataframe.csv"
ETSweepsDataframeFilename<-"Output/ETSweepsDataframeFile.csv"
if(file.exists(ETAvFilename)==1){
  ETAvDataframe<-read.csv(ETAvFilename)
}else{
  AnimalIDList<-c("JF218", "JF220", "JF221",
                  "J0456", "J0460"
                  )
  
  #Filter dataframe for control and daylight only as a proxy for sleep
  SCPPDataframeEventAv<-filter(SCPPDataframeAll, 
                                LightDark==TRUE, 
                                Treatment=="Control")
  
  #For each animal, we are going to loop through each epoch with IIS to create an average ThetaOverDelta for 64+8s interval around the IIS time (9 * 8s intervals)
  
    #Initialise dataframe to store event triggered average for each animal
    ETAvDataframe<-data.frame(
      AnimalIDIndex=factor(),
      Time=integer(),
      AvThetaDelta=double()
    )
   #Initialise dataframe to store event-triggered sweeps for each animal 
    ETSweepsDataframe<-data.frame(
      AnimalIDIndex=factor(),
      TimeForAv=integer(), 
      Time=integer(),
      SpikeCount=integer(),
      ThetaDelta=double()
      )
    
  for(AnimalIndex in 1:length(AnimalIDList)){
    #ETWList<-list()
    AnimalIDCurrent=AnimalIDList[[AnimalIndex]]
    
    SCPPDataframeCurrent<-filter(SCPPDataframeEventAv, 
                                  AnimalIDVariable==AnimalIDCurrent)
    
    
    #Filter the current SCPP for intervals >= 1 spike
    EventsDataframe<-filter(SCPPDataframeCurrent,  SpikeCount>0)
    
    NumberOfEvents<-nrow(EventsDataframe)
    
   
    #Initialise variables and objects for evaluating within animal triggered averages
    NoOfIntervalsForAveraging<-20
    WindowLengthInSecs<-NoOfIntervalsForAveraging*8
    
    ETAv<-rep(0,NoOfIntervalsForAveraging+1)   #Initialise vector for Event-Triggered average 
    
   
    #Loop through all events and compute event triggered average
    SpikeCounterForAveraging<-0
    for(SpikeIndex in 1:NumberOfEvents){
      EventTimeCurrent<-EventsDataframe$InitialisedTime[[SpikeIndex]]
      #Extract epoch centered on IIS
      ETW<-EventTriggeredWindow(EventTimeCurrent, WindowLengthInSecs,SCPPDataframeCurrent$InitialisedTime, 
                            SCPPDataframeCurrent$ThetaOverDelta)
      
      if(nrow(ETW)==NoOfIntervalsForAveraging+1){
        ETAv<-ETAv+ETW$TriggeredWindowData
       # ETWList[[SpikeIndex]]<-ETW
        SpikeCounterForAveraging<-SpikeCounterForAveraging+1
        
        #Append ETSweepsDataframe with current EventTriggeredSweep
          AnimalIDIndex<-rep(AnimalIDCurrent, NoOfIntervalsForAveraging+1)
          TimeForAv<-seq(-(NoOfIntervalsForAveraging*8)/2, (NoOfIntervalsForAveraging*8)/2, 8)
          Time<-ETW$TriggeredWindowTime
          SpikeCount<-rep(SpikeCounterForAveraging, NoOfIntervalsForAveraging+1)
          ThetaDelta<-ETW$TriggeredWindowData
          
          ETSweepsTemp<-data.frame(AnimalIDIndex, TimeForAv, Time, SpikeCount, ThetaDelta)
          
          ETSweepsDataframe<-rbind(ETSweepsDataframe, ETSweepsTemp)
      
      }else{
        #print(SpikeIndex)
      }
    }
    if(SpikeCounterForAveraging>0){
      ETAv<-ETAv/SpikeCounterForAveraging
    }
    #Append ETAvDataframe
    ETAvDataframeTemp<-data.frame(
      AnimalIDIndex=rep(AnimalIDCurrent, NoOfIntervalsForAveraging+1),
      Time=seq(-(NoOfIntervalsForAveraging*8)/2,(NoOfIntervalsForAveraging*8)/2, 8),
      AvThetaDelta=ETAv
    )
    ETAvDataframe<-rbind(ETAvDataframe, ETAvDataframeTemp)
  }
   
    
    write.csv(ETAvDataframe, ETAvFilename)
    write.csv(ETSweepsDataframe, ETSweepsDataframeFilename)
    
    rm(SCPPDataframeCurrent, ETAv, ETAvDataframeTemp, ETW, SCPPDataframeEventAv, ETSweepsDataframe)
}
``` 

Create null event-triggered average by sampling specified number of intervals to sample
```{r NonEventTriggeredAveragingOfThetaDelta, echo=FALSE, include=TRUE}
NETAvFilename<-"Output/NETAvDataframe.csv"
NETSweepsDataframeFilename<-"Output/NETSweepsDataframeFile.csv"
if(file.exists(NETAvFilename)==1){
  NETAvDataframe<-read.csv(NETAvFilename)
}else{
NoIntervalsToSample<-2000
  
   AnimalIDList<-c("JF218", "JF220", "JF221",
                 "J0456", "J0460"
                  )
  
  #Filter dataframe for control and daylight only as a proxy for sleep
  SCPPDataframeEventAv<-filter(SCPPDataframeAll, 
                                LightDark==TRUE, 
                                Treatment=="Control")
  
  #For each animal, we are going to loop through each epoch with IIS to create an average ThetaOverDelta for 64+8s interval around the IIS time (9 * 8s intervals)
  
    #Initialise dataframe to store event triggered average for each animal
    NETAvDataframe<-data.frame(
      AnimalIDIndex=factor(),
      Time=integer(),
      AvThetaDelta=double()
    )
   #Initialise dataframe to store event-triggered sweeps for each animal 
    NETSweepsDataframe<-data.frame(
      AnimalIDIndex=factor(),
      TimeForAv=integer(), 
      Time=integer(),
      SpikeCount=integer(),
      ThetaDelta=double()
      )
    
    for(AnimalIndex in 1:length(AnimalIDList)){
    #ETWList<-list()
    AnimalIDCurrent=AnimalIDList[[AnimalIndex]]
    
    SCPPDataframeCurrent<-filter(SCPPDataframeEventAv, 
                                  AnimalIDVariable==AnimalIDCurrent)
    
    #Initialise variables and objects for evaluating within animal triggered averages
    NoOfIntervalsForAveraging<-20
    WindowLengthInSecs<-NoOfIntervalsForAveraging*8
    
    NETAv<-rep(0,NoOfIntervalsForAveraging+1)   #Initialise vector for Event-Triggered average 
    
   
    #Loop through all events and compute event triggered average
    SpikeCounterForAveraging<-0
    for(SpikeIndex in 1:NoIntervalsToSample){
      #Event time is a random sample of all intervals so might include spikes
      EventTimeCurrent<-sample(SCPPDataframeCurrent$InitialisedTime, 1)
      #Extract epoch centered on IIS
      NETW<-EventTriggeredWindow(EventTimeCurrent, WindowLengthInSecs,SCPPDataframeCurrent$InitialisedTime, 
                            SCPPDataframeCurrent$ThetaOverDelta)
      
      if(nrow(NETW)==NoOfIntervalsForAveraging+1){
        NETAv<-NETAv+NETW$TriggeredWindowData
       # ETWList[[SpikeIndex]]<-ETW
        SpikeCounterForAveraging<-SpikeCounterForAveraging+1
        
        #Append ETSweepsDataframe with current EventTriggeredSweep
          AnimalIDIndex<-rep(AnimalIDCurrent, NoOfIntervalsForAveraging+1)
          TimeForAv<-seq(-(NoOfIntervalsForAveraging*8)/2, (NoOfIntervalsForAveraging*8)/2, 8)
          Time<-NETW$TriggeredWindowTime
          SpikeCount<-rep(SpikeCounterForAveraging, NoOfIntervalsForAveraging+1)
          ThetaDelta<-NETW$TriggeredWindowData
          
          NETSweepsTemp<-data.frame(AnimalIDIndex, TimeForAv, Time, SpikeCount, ThetaDelta)
          
          NETSweepsDataframe<-rbind(NETSweepsDataframe, NETSweepsTemp)
      
      }else{
        #print(SpikeIndex)
      }
    }
    if(SpikeCounterForAveraging>0){
      NETAv<-NETAv/SpikeCounterForAveraging
    }
    #Append ETAvDataframe
    NETAvDataframeTemp<-data.frame(
      AnimalIDIndex=rep(AnimalIDCurrent, NoOfIntervalsForAveraging+1),
      Time=seq(-(NoOfIntervalsForAveraging*8)/2,(NoOfIntervalsForAveraging*8)/2, 8),
      AvThetaDelta=NETAv
    )
    NETAvDataframe<-rbind(NETAvDataframe, NETAvDataframeTemp)
    }
  
  
#Write Nonevent-triggered average and individual sweeps to csv files
      write.csv(NETAvDataframe, NETAvFilename)
  write.csv(NETSweepsDataframe, NETSweepsDataframeFilename)
  
  rm(NETAv, NETAvDataframeTemp, NETW, SCPPDataframeEventAv, NETSweepsDataframe, SCPPDataframeCurrent)
}
```

Plotting Event-triggered averages

```{r PlotEventTiggeredAverage, echo=FALSE, include=TRUE}
#Need to ensure the order of packages loaded correctly for summarise to work with Rmisc package

detach("package:dplyr"); library(plyr); library(Rmisc); library(dplyr)

#Filter dataframe for control and daylight only as a proxy for sleep
SCPPDataframeEventAv<-filter(SCPPDataframeAll, 
                              LightDark==TRUE, 
                              Treatment=="Control")
#Filter for animals

AnimalIDIndex=c("JF218", "JF220", "JF221","J0456", "J0460")

SCPPDataframeEventAv<-filter(SCPPDataframeEventAv, AnimalIDVariable %in% AnimalIDList)

#Determine MeanThetaDelta for each animal
MeanThetaDeltaForAnimal<-group_by(SCPPDataframeEventAv, 
                                  AnimalIDVariable)
MeanThetaDeltaForAnimal<-summarise(MeanThetaDeltaForAnimal, MeanThetaDelta=mean(ThetaOverDelta))

MeansData<-data.frame(MeanThetaDelta=MeanThetaDeltaForAnimal$MeanThetaDelta, AnimalIDIndex=c("JF218", "JF220", "JF221",
                "J0456", "J0460")
                )
#Combine ETSweepsDataframe and NETSweepsDataframe

ThetaDeltaGrp<-group_by(ETSweepsDataframe, AnimalIDIndex, TimeForAv) 
 ThetaDeltaGrp<-summarise(ThetaDeltaGrp, MeanThetaDelta=mean(ThetaDelta),
                        CI_U=CI(ThetaDelta)[1],
                       CI_L=CI(ThetaDelta)[3]
                       )
 
    ThetaDeltaGrp<-mutate(ThetaDeltaGrp, Event="E")
 #Repeat for Non Events but set CI_U and CI_L to the mean to not plot error bars
    NEThetaDeltaGrp<-group_by(NETSweepsDataframe, AnimalIDIndex, TimeForAv) 
    NEThetaDeltaGrp<-summarise(NEThetaDeltaGrp,
                               MeanThetaDelta=mean(ThetaDelta),
                      CI_U=mean(ThetaDelta),
                   CI_L=mean(ThetaDelta)
                    )
      NEThetaDeltaGrp<-mutate(NEThetaDeltaGrp, Event="N")
 
 ThetaDeltaGrp<-rbind(ThetaDeltaGrp, NEThetaDeltaGrp)
 ThetaDeltaGrp<-mutate(ThetaDeltaGrp, Coupling="Strong")
 
ThetaDeltaGrp$Coupling<-ifelse((ThetaDeltaGrp$AnimalIDIndex=="J0456"|ThetaDeltaGrp$AnimalIDIndex=="J0460"),"Weak", "Strong")

#Plotting
ETPlot<-ggplot(ThetaDeltaGrp, aes(x=TimeForAv, y=MeanThetaDelta, color=Event))+
  geom_line()+
  geom_point(aes(shape=Coupling))+
  geom_errorbar(
    aes(ymin=CI_L, ymax=CI_U),
    width=0.2)+
  facet_grid(AnimalIDIndex~., scales="free_y")+
  scale_shape_manual(values=c(16,1)) +
  xlab("Time (s)")+
  ylab(expression(paste(theta, "/", delta)))+
  theme(strip.text = element_blank()) +
  scale_color_grey() +
  theme(legend.position = "none", 
        axis.text.x = element_text(size=10),
        axis.text.y = element_text(size=10), 
        axis.title.x = element_text(size=10),
        axis.title.y = element_text(size=10))

#ETPlot<-ETPlot+geom_hline(aes(yintercept=MeanThetaDelta), MeansData, colour="red")

ETPlot

ggsave("Output/Figures/Fig4/Fig4C.pdf", device="pdf", height=12, width=8, units="cm")
rm(SCPPDataframeEventAv)

```



Example of theta/delta and spike count for WT
```{r SpikeCountThetaDeltaExample, echo=FALSE}

AnimalIDCurrent<-"J0373"
StartTime<-AnimalIDVideoStartEnd$J0373_6[[2]]-7200
EndTime<-AnimalIDVideoStartEnd$J0373_6[[2]]

SleepWakeSpikeCountData<-filter(SCPPDataframeVideoTimesAll, InitialisedTime>StartTime & InitialisedTime<EndTime)

SleepWakeSpikeCountData$ZeroTime<-SleepWakeSpikeCountData$InitialisedTime-min(SleepWakeSpikeCountData$InitialisedTime)




PtSize=0.5
FontSize=10

   
      ThetaOverDeltaPlot<-ggplot(SleepWakeSpikeCountData, 
                                 aes(x=ZeroTime, 
                                     y=ThetaOverDelta, 
                                     color=SleepWake)) +
        scale_colour_grey() +
        geom_point(size=PtSize) +
        scale_y_continuous(limits=c(0,5), breaks=seq(0, 5, 2.5))+
        ylab(expression(paste(theta, "/", delta)))+
        xlab("Time (s)")+
        xlim(c(0, 7200))+
        theme(axis.title.x=element_text(size=FontSize), 
              axis.text.x=element_text(size=FontSize), 
              legend.position = "none", 
              axis.text.y = element_text(size=FontSize),
        axis.title.y = element_text(size=FontSize))
      
      
      
     

   
 ThetaOverDeltaPlot
 
ggsave("Output/Figures/Fig4/Fig4D.pdf",device="pdf",  width=8, height=3, units="cm")      


```
###########
###Fig 5: DPZ treatment and spike count
Compare SpikeNumber in Ctrl and DPZ condition for DPZAM and DPZPM groups

```{r create_fig5_dataframe, ECHO=FALSE}
  Fig5SummaryDataframe<-SummaryDataframe[, c("AnimalID", "Genotype", "TimeZone", "DrugDateTime", "Fig5_DPZAM", "Fig5_DPZPM")]
#Remove rows with missing variables
  Fig5SummaryDataframe<-Fig5SummaryDataframe[complete.cases(Fig5SummaryDataframe),]
```
  
 Select animals that will be used in the analysis all J20 given DPZ_AM with known light dark cycles.
```{r SelectAnimalsAMChunk, echo=FALSE, include=TRUE}

Fig5SummaryDataframeAM<-filter(Fig5SummaryDataframe, Fig5_DPZAM=="YES", Genotype=="J20")

```

Evaluate MeanSpikeRate across all intervals in control and DPZ conditions for each animal and write to Fig5SummaryDataframeAM
```{r SpikeRateDPZAMChunk, include=TRUE, echo=FALSE}
for(i in 1:nrow(Fig5SummaryDataframeAM)){
  AnimalIDCurrent<-Fig5SummaryDataframeAM$AnimalID[i]
  #Filter for current animal in control condition
  SCPPTemp<-filter(SCPPDataframeAll, 
                   AnimalIDVariable==AnimalIDCurrent,
                   Treatment=="Control") 
  #Filter for last 24hours before end of recording in control
  
  SCPPTemp<-filter(SCPPTemp, InitialisedTime>(max(InitialisedTime)-86400))
  #Evaluate mean spikes/8s in control 
  Fig5SummaryDataframeAM$Control[i]<-mean(SCPPTemp$SpikeCount)
  
  #Filter for current animal in DPZ condition
  SCPPTemp<-filter(SCPPDataframeAll, 
                   AnimalIDVariable==AnimalIDCurrent,
                   Treatment=="Drug")
  
  #Filter for last -48- -24hours of recording in control conditions
  
  SCPPTemp<-filter(SCPPTemp, (InitialisedTime<(max(InitialisedTime)-86400))&(InitialisedTime>(max(InitialisedTime)-2*86400)))
  
  #Evaluate mean spikes/8s in control 
  Fig5SummaryDataframeAM$DPZ[i]<-mean(SCPPTemp$SpikeCount)
}

#Convert Fig5SummaryDataframeAM from wide to long format
library(tidyr)
Fig5SummaryDataframeAM_long<-gather(Fig5SummaryDataframeAM, Treatment, SpikePerInt, 7:8)

#ConvertSpikePerInt to SpikeRate
Fig5SummaryDataframeAM_long$SpikeRate<-Fig5SummaryDataframeAM_long$SpikePerInt/8
#Plotting
DPZAMPlot<-ggplot(Fig5SummaryDataframeAM_long, 
                  aes(x=Treatment, 
                      y=SpikeRate,
                      group=AnimalID)) +
  geom_line()+
  geom_point()+
  xlab("Treatment")+
  ylab("Mean Spike/s")+
  scale_y_continuous(limits = c(0, 0.03))

DPZAMPlot

ggsave("Output/DPZAMPlot.png")



```

Repeat for PM group

Select animals that will be used in the analysis all J20 given DPZ_AM with known light dark cycles.
```{r SelectAnimalsPMChunk, echo=FALSE, include=TRUE}

Fig5SummaryDataframePM<-filter(Fig5SummaryDataframe, Fig5_DPZPM=="YES", Genotype=="J20")

```

```{r SpikeRateDPZPMChunk, include=TRUE, echo=FALSE}
for(i in 1:nrow(Fig5SummaryDataframePM)){
  AnimalIDCurrent<-Fig5SummaryDataframePM$AnimalID[i]
  #Filter for current animal in control condition
  SCPPTemp<-filter(SCPPDataframeAll, 
                   AnimalIDVariable==AnimalIDCurrent,
                   Treatment=="Control")
  
  #Filter for last 24hours of recording in control conditions
  
  SCPPTemp<-filter(SCPPTemp, InitialisedTime>(max(InitialisedTime)-86400))
  
  #Evaluate mean spikes/8s in control 
  Fig5SummaryDataframePM$Control[i]<-mean(SCPPTemp$SpikeCount)
  
  #Filter for current animal in DPZ condition
  SCPPTemp<-filter(SCPPDataframeAll, 
                   AnimalIDVariable==AnimalIDCurrent,
                   Treatment=="Drug")
  #Filter for last 24hours of recording in control conditions
  
  SCPPTemp<-filter(SCPPTemp, (InitialisedTime<(max(InitialisedTime)-86400))&(InitialisedTime>(max(InitialisedTime)-2*86400)))
  #Evaluate mean spikes/8s in control 
  Fig5SummaryDataframePM$DPZ[i]<-mean(SCPPTemp$SpikeCount)
}

#Convert Fig5SummaryDataframeAM from wide to long format
library(tidyr)
Fig5SummaryDataframePM_long<-gather(Fig5SummaryDataframePM, Treatment, SpikePerInt, 7:8)

#ConvertSpikePerInt to SpikeRate
Fig5SummaryDataframePM_long$SpikeRate<-Fig5SummaryDataframePM_long$SpikePerInt/8
#Plotting
DPZPMPlot<-ggplot(Fig5SummaryDataframePM_long, 
                  aes(x=Treatment, 
                      y=SpikeRate,
                      group=AnimalID)) +
  geom_line()+
  geom_point()+
  xlab("Treatment")+
  ylab("Mean Spike/s") +
  scale_y_continuous(limits = c(0, 0.03))

DPZPMPlot

ggsave("Output/DPZPMPlot.png")


```


Stats
```{r DPZEffectStatsChunk, include=TRUE, echo=TRUE}
#Combine AM and PM Dataframe
Fig5SummaryDataframeWide<-rbind(Fig5SummaryDataframeAM, Fig5SummaryDataframePM)
rm(Fig5SummaryDataframeAM, Fig5SummaryDataframePM)
#Paired t-test AM
Fig5SummaryDataframeWide$SpikeRateDif<-Fig5SummaryDataframeWide$Control-Fig5SummaryDataframeWide$DPZ

#Test assumptions
SW_DPZ<-NormTesting(Fig5SummaryDataframeWide$SpikeRateDif, "QQ_DPZAM")
SW_DPZ

DPZTTest<-t.test(Fig5SummaryDataframeWide$Control, Fig5SummaryDataframeWide$DPZ, 
                      paired = TRUE)

DPZTTest
```

###Fig 6 AChE absorption assay
The activity of AChE was measured following the protocol of Ellman et al (Biochem Pharmacol 7:88-95. 1961). The thiocline production rate was compared between neocortical brain homogenates for WT and J20 with/without DPZ treatment. A positive control of WT brain homogenate treated with 10uM neostigmine was included in each preparation.

```{r AChEAbsorptionAssay, include=TRUE, echo = FALSE}
AbsorptionFilename<-"~/Dropbox/ANALYSIS/J20_EEG_Manuscript/Data/AChEAbsorptionAssayLong.csv"
AChEAbsorption<-read.csv(AbsorptionFilename, header = TRUE, sep = ",")
AChEAbsorption$RepeatID<-as.factor(AChEAbsorption$RepeatID)

#Select the window for looking at slope
AChEAbsorption<-filter(AChEAbsorption, Time==20)
```

First, do a t-test for genotype in control condition
```{r AChEGenotype, include=TRUE, echo=TRUE}
AChEAbsorptionGenotype<-filter(AChEAbsorption, Treatment=="Ctrl")
#Test normality assumption
DataForTesting <-AChEAbsorptionGenotype$ThioclineRate
  SW_AChE<-NormTesting(DataForTesting, "QQPlot_Thiocline")
  SW_AChE


WTThioclineRate<-filter(AChEAbsorptionTTestData,Genotype=="WT")  
J20ThioclineRate<-filter(AChEAbsorptionTTestData,Genotype=="J20")

#Test normality of differences
  DataForTesting<-WTThioclineRate$ThioclineRate-J20ThioclineRate$ThioclineRate
  
  
  SW_AChEDif<-NormTesting(DataForTesting, "QQPlot_ThioclineDif")

  SW_AChEDif
  
  #The differences are not normally distributed
  
  AChEWilcox<-wilcox.test(WTThioclineRate$ThioclineRate, J20ThioclineRate$ThioclineRate, 
                      paired = TRUE)

AChEWilcox



```


Fit Linear mixed models with GenotypeTreatment as fixed effect and RepeatID as random variable
```{r AChEAbsorptionLME, include=TRUE, echo= TRUE}

AChEAbsorption.model<-lmer(ThioclineRate~ GenotypeTreatment + (1|RepeatID), data=AChEAbsorption, REML = FALSE)

#Plot residuals
plot(fitted(AChEAbsorption.model), residuals(AChEAbsorption.model))
```

Residuals have trend so we log transform the data

```{r AChEAbsorptionLMELogAssumptions, include=TRUE, echo=TRUE}
minThioclineRate<-min(AChEAbsorption$ThioclineRate)
AChEAbsorption$ThioclineRateTranslate<-AChEAbsorption$ThioclineRate+minThioclineRate+1
AChEAbsorption$LogThioclineRate<-log(AChEAbsorption$ThioclineRateTranslate)


#Linear mixed models with GenotypeTreatment as fixed effect and RepeatID as random variable
AChEAbsorption.model<-lmer(LogThioclineRate~ GenotypeTreatment + (1|RepeatID), data=AChEAbsorption, REML = FALSE)

#Plot residuals
plot(fitted(AChEAbsorption.model), residuals(AChEAbsorption.model))


#qqplot

qqnorm(residuals(AChEAbsorption.model))


```

The data fit the assumptions for the linear mixed model of homoscedactity and normality as determined by residual plot and qqnormal plot of residuals. Proceed with linear mixed model test and post-hoc tests..

```{r AChEAbsorptionLMETest, include=TRUE, echo=FALSE}

# summary

summary(AChEAbsorption.model)


#Test signficance of genotype fixed effect using a chi-squared statistic
AChEAbsorption.null<-lmer(LogThioclineRate~ (1|RepeatID), data=AChEAbsorption, REML = FALSE)
anova(AChEAbsorption.model, AChEAbsorption.null)




#Perform post-hoc tests. Use one sided for NSTG < DPZ < Ctrl. Use two-sided for  J20 and WT 
summary(glht(AChEAbsorption.model, linfct = mcp(GenotypeTreatment = "Tukey"), alternative = "less", test = adjusted("holm")))


summary(glht(AChEAbsorption.model, linfct = mcp(GenotypeTreatment = "Tukey"), alternative = "greater", test = adjusted("holm")))

summary(glht(AChEAbsorption.model, linfct = mcp(GenotypeTreatment = "Tukey"), alternative = "two.sided", test = adjusted("holm")))

```

```{r AChEAbsorptionPlot, include=TRUE, echo=FALSE}

#Plotting
Filename<-"./Output/Figures/Fig5/Fig5B.pdf"

FontSize<-10

#Reorder the factor variables
AChEAbsorption$GenotypeTreatment<-as.factor(AChEAbsorption$GenotypeTreatment)
AChEAbsorption$GenotypeTreatment<-factor(AChEAbsorption$GenotypeTreatment, levels=c("WT_Ctrl","J20_Ctrl","WT_DPZ", "J20_DPZ", "WT_NSTG"))

AChEAbsorptionPlot<-ggplot(AChEAbsorption, 
                           aes(x=GenotypeTreatment,
                               y=ThioclineRate,
                               color=RepeatID,
                               group=RepeatID)) +     
  geom_point() +
  geom_line() +
  ylab("Thiocline prod rate (nMol/min)") +
  xlab("") 
  
AChEAbsorptionPlot<- AChEAbsorptionPlot +
  theme_bw() +
  scale_x_discrete(labels=c("WT Ctrl",  "J20 Ctrl", "WT DPZ","J20 DPZ", "WT NSTG"))+
  scale_y_continuous(limits=c(-0.5,2))+
  theme(panel.border=element_blank(), 
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), 
    axis.line=element_line(colour = "black"), 
    axis.text.x = element_text(angle=90, size=FontSize),
    axis.text.y = element_text(size=FontSize),
    axis.title.x = element_text(size=FontSize),
    axis.title.y = element_text(size=FontSize),
    legend.position = "none", 
    plot.margin=unit(c(1.2,1,1,1),  "cm"))

AChEAbsorptionPlot

ggsave(Filename, device="pdf", height=8, width=8, units="cm")
```
########
###CHAT quantification
The data was imported from Anne-Laure's github:https://github.com/AnneLaureHemonnot/ChAT_Analysis. The data in that project was saved into ChAT_Analysis/Output. Here, I import the csv

```{r CHATQuantification, echo=FALSE}
CHATDataFile<-"~/Dropbox/ANALYSIS/CHAT_staining/ChAT_Analysis/Output/DataAll.csv"

FigureFilename<-"Output/Figures/Fig5/Fig5A.pdf"

CHATData<-read.csv(CHATDataFile, sep=";", header=TRUE)
CHATData$GenotypeCombined<- ifelse(CHATData$Genotype=="AD - Donepezil", "J20", "WT")
CHATData$GenotypeCombined<-as.factor(CHATData$GenotypeCombined)
CHATData$GenotypeCombined<-factor(CHATData$GenotypeCombined, level=c("WT", "J20"))

FontSize=10

CHATPlot<-ggplot(CHATData, 
                 aes(x=GenotypeCombined, 
                     y=EstPopUserDefThickness))+
  geom_point()+
  facet_grid(.~RegionVar)+
  ylab("Estimated count")+
  scale_y_continuous(limits=c(0, 6000), breaks=seq(0, 6000, 2000))+
  xlab("Genotype")+
  theme(axis.title.y=element_text (size = FontSize))+
  theme(axis.title.x=element_text (size = FontSize))+
  theme(axis.text.y =element_text (size = FontSize))+
  theme(axis.text.x =element_text (size = FontSize))

CHATPlot

ggsave(FigureFilename, device="pdf", height=6, width=6, units="cm")
```

LME for ChAT:
```{r LME_ChAT, include=TRUE, echo=TRUE}

CHAT.model<-lmer(EstPopUserDefThickness~ GenotypeCombined + RegionVar+(1|ID), data=CHATData, REML = FALSE)

#Plot residuals
plot(fitted(CHAT.model), residuals(CHAT.model))

#QQ plot

qqnorm(residuals(CHAT.model))

#No large deviations from model assumptions

summary(CHAT.model)
coef(CHAT.model)
#Null model
CHAT.null<-lmer(EstPopUserDefThickness~  RegionVar+(1|ID), data=CHATData, REML = FALSE)

anova(CHAT.null,CHAT.model)


```

